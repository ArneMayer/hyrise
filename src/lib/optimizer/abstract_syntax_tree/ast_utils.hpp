#pragma once

#include <memory>

#include "types.hpp"

/**
 * This file contains functions that operate on AbstractSyntaxTrees, but, in order to keep the interface of
 * AbstractASTNode clean, are not part of the class.
 */

namespace opossum {

class AbstractASTNode;

/**
 * Check whether the AST contains a Predicate or Inner Join that filters its output according to the expression
 * `descendant_a.column_id_a scan_type descendant_b.column_id_b`
 * @param column_id_a ColumnID in descendant_a
 * @param column_id_b ColumnID in descendant_b
 */
bool ast_contains_join_edge(const std::shared_ptr<const AbstractASTNode>& node,
                            const std::shared_ptr<const AbstractASTNode>& descendant_a,
                            const std::shared_ptr<const AbstractASTNode>& descendant_b, ColumnID column_id_a,
                            ColumnID column_id_b, ScanType scan_type);

/**
 * Check whether the AST contains a Predicate or Inner Join that filters its output according to the expression
 * `column_id_a scan_type column_id_b`
 * @param column_id_a, column_id_b output ColumnIDs of node
 */
bool ast_contains_join_edge(const std::shared_ptr<const AbstractASTNode>& node, ColumnID column_id_a,
                            ColumnID column_id_b, ScanType scan_type);

/**
 * Within the Columns returned by node, find the first ColumnID generated by leaf. The recursive search will walk
 * through Predicates, Sorts and Inner Joins and consider all other nodes opaque, i.e. not recurse into their children
 */
ColumnID ast_get_first_column_id_of_descendant(const std::shared_ptr<const AbstractASTNode>& node,
                                               const std::shared_ptr<const AbstractASTNode>& descendant);

}  // namespace opossum